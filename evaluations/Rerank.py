from __future__ import print_function, absolute_importfrom utils import to_numpyimport numpy as npimport heapqimport torchfrom Model2Feature import Model2Featuresfrom evaluations import Recall_at_ks, pairwise_similarityimport os# Now only for JD competition only, for other data sets, need a bit modificationdef re_rank(gallery_features, gallery_ids, k=10):    """    :param gallery_features:    :param gallery_ids:    :param k: top -k    :return: new query features    """    sim_mat = pairwise_similarity(gallery_features)    sim_mat = to_numpy(sim_mat)    gallery_ids = np.asarray(gallery_ids)    reranked_features = torch.ones(gallery_features.shape)    for i in range(len(gallery_ids)):        x = sim_mat[i]        idx = heapq.nlargest(k, range(len(x)), x.take)        # origin feature + average top-k        # another way: avg( origin feat, top-k) also have tried        new_query = torch.mean(gallery_feature[idx], 0)        reranked_features[i] = new_query        if i % 200 == 0:            print(i)    return reranked_features        # new_querys.append(gallery_features[i] + np.sum(gallery_features[indice]))def k_reciprocal_neigh(initial_rank, i, k1):    forward_k_neigh_index = initial_rank[i, :k1 + 1]    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]    fi = np.where(backward_k_neigh_index == i)[0]    return forward_k_neigh_index[fi]def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):    # The following naming, e.g. gallery_num, is different from outer scope.    # Don't care about it.    original_dist = np.concatenate(        [np.concatenate([q_q_dist, q_g_dist], axis=1),         np.concatenate([q_g_dist.T, g_g_dist], axis=1)],        axis=0)    original_dist = 2. - 2 * original_dist  # np.power(original_dist, 2).astype(np.float32)    original_dist = np.transpose(1. * original_dist / np.max(original_dist, axis=0))    V = np.zeros_like(original_dist).astype(np.float32)    # initial_rank = np.argsort(original_dist).astype(np.int32)    # top K1+1    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))    query_num = q_g_dist.shape[0]    all_num = original_dist.shape[0]    for i in range(all_num):        # k-reciprocal neighbors        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)        k_reciprocal_expansion_index = k_reciprocal_index        for j in range(len(k_reciprocal_index)):            candidate = k_reciprocal_index[j]            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2. / 3 * len(                    candidate_k_reciprocal_index):                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])        V[i, k_reciprocal_expansion_index] = 1. * weight / np.sum(weight)    original_dist = original_dist[:query_num, ]    if k2 != 1:        V_qe = np.zeros_like(V, dtype=np.float32)        for i in range(all_num):            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)        V = V_qe        del V_qe    del initial_rank    invIndex = []    for i in range(all_num):        invIndex.append(np.where(V[:, i] != 0)[0])    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)    for i in range(query_num):        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)        indNonZero = np.where(V[i, :] != 0)[0]        indImages = []        indImages = [invIndex[ind] for ind in indNonZero]        for j in range(len(indNonZero)):            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]],                                                                               V[indImages[j], indNonZero[j]])        jaccard_dist[i] = 1 - temp_min / (2. - temp_min)    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value    del original_dist    del V    del jaccard_dist    final_dist = final_dist[:query_num, query_num:]    return final_dist# return sim_mat### def main():os.environ["CUDA_VISIBLE_DEVICES"] = "0"data = 'jd'r = '/opt/intern/users/xunwang/checkpoints/bin/jd/VGG16-BN-Net-DIM512-168-lr1e-5/ckp_ep80.pth.tar'net = 'VGG16-BN'gallery_feature, gallery_labels, query_feature, query_labels = \    Model2Features(data=data, net=net, ckp_path=r, dim=512,                   batch_size=100, nThreads=16)# re_rank_feat = re_rank(gallery_features=gallery_feature, gallery_ids=gallery_labels, k=4)ori_sim_mat = pairwise_similarity(gallery_feature)# sim_mat = pairwise_similarity(re_rank_feat) - torch.eye(len(gallery_labels))r0 = Recall_at_ks(sim_mat=ori_sim_mat, data='jd', gallery_ids=gallery_labels)print(r0)# r1 = Recall_at_ks(sim_mat=sim_mat, data='cub', gallery_ids=gallery_labels)# print(r1)gallery_feature = gallery_feature.cpu().numpy()query_feature = query_feature.cpu().numpy()print('calculate initial distance')q_g_dist = np.dot(query_feature, np.transpose(gallery_feature))q_q_dist = np.dot(query_feature, np.transpose(query_feature))g_g_dist = np.dot(gallery_feature, np.transpose(gallery_feature))re_rank = re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=4)r2 = Recall_at_ks(sim_mat=re_rank, data='jd', gallery_ids=gallery_labels)print(r2)